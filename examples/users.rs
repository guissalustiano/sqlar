pub struct FindUserParams {
    pub eq_id: i32,
}
pub struct FindUserRows {
    pub id: Option<i32>,
    pub name: Option<String>,
}
pub async fn find_user(
    c: &impl tokio_postgres::GenericClient,
    p: FindUserParams,
) -> Result<Vec<FindUserRows>, tokio_postgres::Error> {
    c.query("SELECT id, name FROM users WHERE id = $1", &[&p.eq_id])
        .await
        .map(|rs| {
            rs.into_iter()
                .map(|r| FindUserRows {
                    id: r.get(0),
                    name: r.get(1),
                })
                .collect()
        })
}

pub struct ListUsersRows {
    pub id: Option<i32>,
    pub name: Option<String>,
}
pub async fn list_users(
    c: &impl tokio_postgres::GenericClient,
) -> Result<Vec<ListUsersRows>, tokio_postgres::Error> {
    c.query("SELECT id, name FROM users", &[])
        .await
        .map(|rs| {
            rs.into_iter()
                .map(|r| ListUsersRows {
                    id: r.get(0),
                    name: r.get(1),
                })
                .collect()
        })
}

pub struct CreateUserParams {
    pub name: String,
}
pub async fn create_user(
    c: &impl tokio_postgres::GenericClient,
    p: CreateUserParams,
) -> Result<u64, tokio_postgres::Error> {
    c.execute("INSERT INTO users (name) VALUES ($1)", &[&p.name]).await
}

pub struct UpdateUserParams {
    pub eq_id: i32,
    pub set_name: String,
}
pub async fn update_user(
    c: &impl tokio_postgres::GenericClient,
    p: UpdateUserParams,
) -> Result<u64, tokio_postgres::Error> {
    c.execute("UPDATE users SET name = $2 WHERE id = $1", &[&p.eq_id, &p.set_name]).await
}

pub struct DeleteUserParams {
    pub eq_id: i32,
}
pub async fn delete_user(
    c: &impl tokio_postgres::GenericClient,
    p: DeleteUserParams,
) -> Result<u64, tokio_postgres::Error> {
    c.execute("DELETE FROM users WHERE id = $1", &[&p.eq_id]).await
}

// The main is not autogenerated, but is needed to example folder to compile
fn main() {}